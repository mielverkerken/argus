#!/bin/bash

shopt -s extglob

typeset -r PCI_VENDOR_INTEL="0x8086"
typeset -r PCI_DEVICE_INTEL_I350="0x1521"
typeset -r PCI_DEVICE_INTEL_X710="0x1572"

typeset -i ARGUS_CONFIGURED=0

if [[ -r /etc/sysconfig/argus-hints ]] ; then
	. /etc/sysconfig/argus-hints
	ARGUS_CONFIGURED=1
fi

if [[ -r /etc/sysconfig/argus ]] ; then
	. /etc/sysconfig/argus
fi
ARGUS_DIRECT_ATTACH_SENSORS=${ARGUS_DIRECT_ATTACH_SENSORS:-no}

if [[ -r /etc/os-release ]] ; then
	. /etc/os-release
fi

is_sensor_appliance(){
	if [[ "${QOSIENT_SYSTEM_TYPE}" == sensor \
	      || -z "${QOSIENT_SYSTEM_TYPE}" ]] ; then
		return 0;
	fi
	return 1
}

# search for network devices that will only be used for packet
# capture.
# $1 == numa node
find_monitor_ethdevs(){
	if [[ ! "$1" = all ]] ; then
		return
	fi

	str=""
	pushd /sys/class/net > /dev/null
	for x in * ; do
		if [[ ! -f ${x}/device/vendor ]] ; then
			continue
		fi

		if [[ ! $(cat ${x}/device/vendor) \
		      == ${PCI_VENDOR_INTEL} ]] ; then
			continue
		fi

		devid=$(cat ${x}/device/device)

		# All on-board devices are used for management by sensor.
		if is_sensor_appliance ; then
			if [[ -f ${x}/device/acpi_index ]] ; then
				continue
			fi
			if [[ ${devid} == ${PCI_DEVICE_INTEL_X710} ]] ; then
				continue
			fi
		else
			if [[ ! ( ${devid} == ${PCI_DEVICE_INTEL_I350} || \
				  ${devid} == ${PCI_DEVICE_INTEL_X710} ) ]] ; then
				continue
			fi
			if [[ ( -f ${x}/device/acpi_index ) && \
			      ( ${devid} == ${PCI_DEVICE_INTEL_I350} ) ]] ; then
				continue
			fi
		fi

		str+=" ${x}"
	done
	popd > /dev/null
	echo  ${str}
}

# $1 = numa node
# $2 = number of devs per numa node
find_monitor_hwcapdevs() {
	if [[ "$1" = all ]] ; then
		return
	fi

	node=$1
	devspernode=$2
	## Search for Napatech cards
	devs=$(tcpdump -D | \
	  awk '/NT 3G /{split($1, str, /\./); printf("%s ", str[2])};')
	for d in $devs ; do
		num=${d##*[a-zA-Z]}
		if [[ "$num" = +([0-9]) ]] ; then
			if (( num >= (node*devspernode) && \
			      num < ((node+1)*devspernode) )) ; then
				echo "$d"
			fi
		fi
	done
}

# $1 = numa node
# $2 = number of devs per numa node
find_monitor_devs() {
	find_monitor_ethdevs $1
	find_monitor_hwcapdevs $1 $2
}

# search for on-board network interfaces.  These should always have
# an acpi index.
# $1 = numa node
find_mgmt_devs(){
	if [[ ! "$1" = all ]] ; then
		return
	fi

	str=""
	pushd /sys/class/net > /dev/null

	for x in * ; do
		if [[ ! -f ${x}/device/acpi_index ]] ; then
			continue
		fi

		# collectors use the x710 for monitoring
		if ! is_sensor_appliance ; then
			vendor=$(cat ${x}/device/vendor)
			devid=$(cat ${x}/device/device)

			if [[ ( ${vendor} == ${PCI_VENDOR_INTEL} && \
				${devid} == ${PCI_DEVICE_INTEL_X710} ) ]] ; then
				continue
			fi
		fi

		str+=" ${x}"
	done
	popd > /dev/null
	echo  ${str}
}

# usage: firewall_cmd_drop add|remove <interface_name>
# run firewall-cmd with args needed to discard packets entering/leaving
# a particular interface.
firewall_cmd_drop(){
	local cmd="--add-rule"

	if [[ "$1" == remove ]] ; then
		cmd="--remove-rule"
	fi

	# "eb" doesn't work in proto for --direct configs, even though
	# it's documented.
	for proto in ipv4 ipv6 ; do
		firewall-cmd \
		  --direct \
		  ${cmd} ${proto} filter OUTPUT 0 \
		  --out-interface ${itf} -j DROP
		firewall-cmd \
		  --direct \
		  ${cmd} ${proto} filter INPUT 0 \
		  --in-interface ${itf} -j DROP
	done
}

# 1-gigabit sensor nodes monitor traffic on the I350 interfaces.  Get
# rid of addresses and configure the firewall to block everything,
# in and out.  libpcap should still see received traffic.
#
# $1 = numa node.  Really, only a value of "all" does anything here.
sensor_setup_monitor_devs(){
	for itf in $(find_monitor_ethdevs $1) ; do
		firewall_cmd_drop add ${itf}
		nmcli con modify --temporary ${itf} ipv4.method disabled
		nmcli con modify --temporary ${itf} ipv6.method ignore
		nmcli con modify --temporary ${itf} 802-3-ethernet.mtu 9000
		nmcli con down ${itf}
		nmcli con modify --temporary ${itf} connection.autoconnect yes
		nmcli --wait 0 con up ${itf}
	# itf
	done
}

sensor_setup_mgmt_devs(){
	if [[ ! "$1" = all ]] ; then
		return
	fi
	firewall-cmd --add-port=561/tcp
}

# $1 = numa node
sensor_setup(){
	sensor_setup_monitor_devs $1
	sensor_setup_mgmt_devs
}

# $1 = numa node
sensor_restore_monitor_devs(){
	if [[ ! "$1" = all ]] ; then
		return
	fi
	for itf in $(find_monitor_ethdevs $1) ; do
		firewall_cmd_drop remove ${itf}
		if [[ $(nmcli --field connection.autoconnect con show ${itf} \
		        | awk '{print $2}') == no ]] ; then
			nmcli con down ${itf}
		else
			nmcli --wait 0 con up ${itf}
		fi
	done
}

sensor_restore_mgmt_devs(){
	if [[ ! "$1" = all ]] ; then
		return
	fi
	firewall-cmd --remove-port=561/tcp

	for itf in $(find_mgmt_devs $1) ; do
		if [[ $(nmcli --field connection.autoconnect con show ${itf} \
		        | awk '{print $2}') == no ]] ; then
			nmcli con down ${itf}
		else
			nmcli --wait 0 con up ${itf}
		fi
	done
}

# $1 = numa node
sensor_restore(){
	# discard temporary changes
	nmcli con reload

	sensor_restore_monitor_devs $1
	sensor_restore_mgmt_devs $1
}

generate_monitor_id() {
	local uuid=$(dmidecode -s system-uuid)
	if [[ -z "$uuid" ]] ; then
		uuid=$(uuidgen -t)
	fi

	# uuid + interface name
	echo "${uuid}"
}

get_monitor_id() {
	local cachedir="/var/cache/argus"
	local idcache="${cachedir}/monitor-id"

	# Look for cached value.  If not found, make a new monitor
	# id and save it.
	if [[ -f $idcache ]] ; then
		cat $idcache
	else
		mkdir -p ${cachedir}
		generate_monitor_id | tee ${idcache}
	fi
}

generate_sensor_config_default() {
	numanode=$1
	infalias=""
	if [[ "$numanode" = all ]] ; then
		(( offset = 0 ))
	else
		(( offset = numanode + 1 ))
		infalias="//arg0"
	fi

	echo "ARGUS_MONITOR_ID=$(get_monitor_id)"
	for itf in $(find_monitor_devs $1 $2) $(find_mgmt_devs $1) ; do
		echo "ARGUS_INTERFACE=ind:${itf}${infalias}"
	done
	echo 'ARGUS_BIND_IP="::1,127.0.0.1"'
	echo "ARGUS_MONITOR_ID_INCLUDE_INF=yes"
	echo "ARGUS_ACCESS_PORT=$((562+offset))"
	echo "ARGUS_MIN_SSF=0"
	echo "ARGUS_MAX_SSF=0"
	echo "ARGUS_CAPTURE_DATA_LEN=64"
	echo "ARGUS_GENERATE_PACKET_SIZE=yes"
	echo "ARGUS_GENERATE_JITTER_DATA=yes"
	echo "ARGUS_GENERATE_MAC_DATA=yes"
	echo "ARGUS_GENERATE_APPBYTE_METRIC=yes"
	echo "ARGUS_GENERATE_TCP_PERF_METRIC=yes"
	echo "ARGUS_GENERATE_BIDIRECTIONAL_TIMESTAMPS=yes"
	echo "ARGUS_CAPTURE_FULL_CONTROL_DATA=yes"
	echo 'ARGUS_CONTROLPLANE_PROTO="udp:name,udp:nicname,udp:domain,xns-time,udp:ntp,udp:router,udp:ripng,timed,mdns,mdnsresponder,udp:bootps,udp:bootpc"'
	echo "ARGUS_MAR_STATUS_INTERVAL=5"
	echo "ARGUS_PCAP_DISPATCH_NUM=32"

        if [[ ! $1 = all ]] ; then
                return
        fi

        echo 'ARGUS_EVENT_DATA="prog:/usr/bin/argus-top:30s:compress"'
        echo 'ARGUS_EVENT_DATA="prog:/usr/bin/argus-ipaddr:30s:compress"'
}

if (( $# < 3 )) ; then
	echo "usage: $0 start|stop <numa_node> <devs_per_node>" > /dev/stderr
	exit 1
fi

if [[ ( ! "$2" = +([0-9]) ) && ( ! "$2" = all ) ]] ; then
	echo "numa_node must be a non-negative integer or \"all\"" > /dev/stderr
	exit 1
fi

if [[ ( ! "$3" = +([0-9]) ) && ( ! "$2" = all ) ]] ; then
	echo "devs_per_node must be a non-negative integer or \"all\"" \
	  > /dev/stderr
	exit 1
fi

if [[ "$1" == start ]] ; then
	mkdir -p /run/argus
	if is_sensor_appliance ; then
		sensor_setup "$2" > /dev/null
		generate_sensor_config_default "$2" "$3" > /run/argus/argus."$2".conf
		sensor_setup_mgmt_devs "$2"
	else
		echo "NUMA configurations only applied to sensors." > /dev/stderr
		exit 1
	fi
elif [[ "$1" == stop ]] ; then
	if is_sensor_appliance ; then
		sensor_restore "$2" > /dev/null
	else
		echo "NUMA configurations only applied to sensors." > /dev/stderr
		exit 1
	fi
else
	echo "$0: Don't know what to do." > /dev/stderr
	exit 1
fi

exit 0

